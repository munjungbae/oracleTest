-- 트랜잭션
DROP TABLE DEP02;

--테이블 구조만 복사
CREATE TABLE DEP02
AS SELECT * FROM DEPARTMENTS
WHERE 1=0;

DESC DEP02;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'DEP02';
--내용복사
INSERT INTO DEP02 SELECT * FROM DEPARTMENTS;
--DEP02 테이블 확인
SELECT * FROM DEP02;
--커밋 전 내용 롤백
ROLLBACK;
--롤백테스트
DELETE FROM DEP02;
--세이브 포인트
SAVEPOINT C1;

DELETE FROM DEP02 WHERE DEPARTMENT_ID = 90;

--SAVEPOINT 까지 롤백
ROLLBACK TO C1;

--VIEW 생성하기
CREATE VIEW VIEW_EMP01
AS SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;
--뷰 생성 확인
SELECT * FROM VIEW_EMP01;
--VIEW 수정하기
UPDATE VIEW_EMP01 SET SALARY = 4500 WHERE EMPLOYEE_ID = 200;


--EMPLOYEES를 복사해서 EMP_COPY 생성
CREATE TABLE EMP_COPY
AS 
SELECT * FROM EMPLOYEES;
--
SELECT * FROM EMP_COPY;
-- 뷰를 제거하기
DROP VIEW VIEW_EMP01;

SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';

--가상뷰에 입력하기 (가상테이블에 컬럼4개 입력, 원본이 10개인데 그중에 NOT NULL이 존재, 가상테이블에 포함되어 있지 않다면?)
--즉 가상뷰 VIEW_EMP01 의 원본 EMPLOYEES의 속성중 NOT NULL이 존재하기 때문에 아래 방식으로는 입력 불가능
INSERT INTO VIEW_EMP01 VALUES (5,'MUN',4400,5);
--가상 테이블에 값을 입력하기 위해선 NOT NULL조건이 존재하는 속성을 전부 가져와야 입력가능
CREATE VIEW VIEW_EMP02
AS SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID
FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;

INSERT INTO VIEW_EMP02 VALUES (5,'JUNGBAE','MUN','123',TO_DATE('2021/12/24','YYYY/MM/DD'),'123');

SELECT * FROM VIEW_EMP02;

--
CREATE VIEW VIEW_EMP03
AS SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID
FROM EMP_COPY;

INSERT INTO VIEW_EMP03 VALUES (5,'JUNGBAE','MUN','123',TO_DATE('2021/12/24','YYYY/MM/DD'),'123');

SELECT * FROM VIEW_EMP03 WHERE EMPLOYEE_ID = 5;
SELECT * FROM VIEW_EMP03;

SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID = 5;
SELECT * FROM EMP_COPY;

--가상뷰에서 삭제 진행
DELETE FROM VIEW_EMP03 WHERE EMPLOYEE_ID = 5;


--복합뷰 설정 ( 복합 뷰 : 두개의 테이블을 조인하여 가상의 테이블을 생성 ) 
CREATE VIEW VIEW_EMP_DEPT
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, E.DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.DEPARTMENT_ID DESC;

SELECT * FROM VIEW_EMP_DEPT;
SELECT DISTINCT DEPARTMENT_ID, DEPARTMENT_NAME 
FROM VIEW_EMP_DEPT;

--부셔명 IT의 연봉 평균과 최고값, 최저 값을 구하라
SELECT DEPARTMENT_NAME, MAX(SALARY), MIN(SALARY) FROM VIEW_EMP_DEPT
WHERE DEPARTMENT_NAME = 'IT' 
GROUP BY DEPARTMENT_NAME;

--FORCE 사용하여 강제로 뷰 생성, REPLACE는 해당이름의 뷰가 있으면 삭제 후 재생성

CREATE OR REPLACE FORCE VIEW VIEW_FORCE
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID
FROM EMP20;

--ROWNUM 활용
SELECT * 
FROM EMPLOYEES;

SELECT ROWNUM, DEPARTMENT_ID, EMPLOYEE_ID, FIRST_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID = 100
ORDER BY FIRST_NAME DESC;

--ROWNUM을 부여 한 뒤 ORDER BY로 다시 정렬하면 값이 흐트러지게 된다
--이를 다시 순서대로 부여하고 싶을 때 VIEW 사용
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;
--뷰 사용하여 ROWNUM 정렬
--ORDER BY로 테이블 정렬 후 VIEW 생성
CREATE OR REPLACE VIEW VIEW_HIRE_DATE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;
--생성된 VIEW테이블에 ROWNUM을 사용하여 번호부여
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM VIEW_HIRE_DATE;
--ROWNUM을 사용하여 원하는 개수만큼만 출력하기 (부등호만사용)
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE 
FROM VIEW_HIRE_DATE
WHERE ROWNUM <= 4;

--인라인 뷰
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM (SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
      FROM EMPLOYEES
      ORDER BY HIRE_DATE DESC)
WHERE ROWNUM < 6;
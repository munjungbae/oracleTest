--문제 풀이용 로컬 hr3

--1. 사원 번호와 사원명과 부서명과 부서의 위치를 출력하는 뷰(VIEW_LOC)를 작성하라.

CREATE OR REPLACE VIEW VIEW_LOC
AS
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT * FROM VIEW_LOC;
DROP VIEW VIEW_LOC;

--2. 30번 부서 소속 사원의 이름과 입사일과 부서명을 출력하는 뷰(VIEW_DEPT30)를 작성하라.
CREATE OR REPLACE VIEW VIEW_DEPT30
AS
SELECT E.DEPARTMENT_ID, FIRST_NAME, HIRE_DATE, DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID LIKE 30;

SELECT * FROM VIEW_DEPT30;
DROP VIEW VIEW_DEPT30;
--3. 부서별 최대 급여 정보를 가지는 뷰(VIEW_DEPT_MAXSAL)를 생성하라.
CREATE OR REPLACE VIEW VIEW_DEPT_MAXSAL
AS
SELECT JOB_ID ,MAX(SALARY) AS "SALARY"
FROM EMPLOYEES 
GROUP BY JOB_ID;

SELECT * FROM VIEW_DEPT_MAXSAL;
DROP VIEW VIEW_DEPT_MAXSAL;

--4. 급여를 많이 받는 순서대로 3명만 출력하는 뷰(VIEW_SAL_TOP3)와 인라인 뷰로 작성하라.
SELECT ROWNUM, FIRST_NAME, SALARY
FROM (SELECT FIRST_NAME, SALARY
      FROM EMPLOYEES
      ORDER BY SALARY DESC)
      WHERE ROWNUM < 4;
      
    

--점수테이블 생성
CREATE TABLE SCORE (
    HAKBUN NUMBER(4),
    HAKNAME VARCHAR2(20) NOT NULL,
    KOR NUMBER(4) NOT NULL,
    ENG NUMBER(4) NOT NULL,
    MAT NUMBER(4) NOT NULL,
    TOT NUMBER(4) DEFAULT 0,
    AVE NUMBER(5,1) DEFAULT 0,
    RANK NUMBER(4)
);
ALTER TABLE SCORE ADD CONSTRAINT SCORE_PK PRIMARY KEY(HAKBUN);

DROP TABLE SCORE;

--프로시저 생성
CREATE OR REPLACE PROCEDURE SCORE_PROC(
    S_HAKBUN SCORE.HAKBUN%TYPE,
    S_HAKNAME SCORE.HAKNAME%TYPE,
    S_KOR SCORE.KOR%TYPE,
    S_ENG SCORE.ENG%TYPE,
    S_MAT SCORE.MAT%TYPE
)
IS
    S_TOT SCORE.TOT%TYPE;
    S_AVE SCORE.AVE%TYPE;
BEGIN
    S_TOT := S_KOR + S_ENG + S_MAT;
    S_AVE := (S_KOR + S_ENG + S_MAT) / 3;

    INSERT INTO SCORE(HAKBUN, HAKNAME, KOR, ENG, MAT, TOT, AVE) 
    VALUES(S_HAKBUN, S_HAKNAME, S_KOR, S_ENG, S_MAT, S_TOT, S_AVE);
END;
/

--랭크적용 프로시저
CREATE OR REPLACE PROCEDURE SCORE_RANK_PROC
IS
    S_RANK SCORE.RANK%TYPE;
    SCORE_ROW SCORE%ROWTYPE;
BEGIN
    UPDATE SCORE SET RANK = (SELECT S_RANK 
                             FROM(SELECT HAKBUN, RANK() OVER(ORDER BY TOT DESC) AS S_RANK 
                                  FROM SCORE))
    WHERE SCORE.HAKBUN = HAKBUN;
END;
/
SELECT S_RANK FROM(SELECT HAKBUN, RANK() OVER(ORDER BY TOT DESC) AS S_RANK FROM SCORE);

--윈도우 함수를 사용하여 랭크적용

CREATE OR REPLACE PROCEDURE SCORE_RANK_PROC
IS
    SCORE_ROW SCORE%ROWTYPE;
    CURSOR C1 IS 
    SELECT RANK() OVER(ORDER BY TOT DESC) RANK FROM SCORE ORDER BY TOT DESC;
BEGIN
    FOR SCORE_ROW IN C1 LOOP
        UPDATE SCORE SET RANK = SCORE_ROW.RANK WHERE HAKBUN = SCORE_ROW.HAKBUN;
    END LOOP;
    COMMIT;
END;
/

EXECUTE SCORE_PROC(1,'홍길동',99,80,85); 
EXECUTE SCORE_PROC(2,'문정배',33,4,66); 
EXECUTE SCORE_PROC(3,'김퍼랭',55,66,88); 
EXECUTE SCORE_RANK_PROC;

SELECT * FROM SCORE ORDER BY RANK;

--트리거 적용
CREATE OR REPLACE TRIGGER SCORE_INPUT
    AFTER INSERT ON SCORE
BEGIN
    UPDATE SCORE SET TOT = (KOR+ENG+MAT);
    UPDATE SCORE SET AVE = (KOR+ENG+MAT)/3;
END;
/

INSERT INTO SCORE(HAKBUN, HAKNAME, KOR, ENG, MAT) VALUES(4,'홍길동',99,80,85);

SELECT * FROM SCORE;

ROLLBACK;
--before 활용 트리거
CREATE OR REPLACE TRIGGER SCORE_TRIGGER01
    BEFORE INSERT ON SCORE
    FOR EACH ROW
BEGIN
    :NEW.TOTAL := :NEW.KOR + :NEW.ENG + :NEW.MAT;
    :NEW.AVG := ROUND((:NEW.KOR + :NEW.ENG + :NEW.MAT) / 3, 1);
END;

/
INSERT INTO SCORE(NO,NAME,KOR,ENG,MAT) VALUES((SELECT NVL(MAX(NO),0)+1 FROM SCORE),DBMS_RANDOM.STRING('U',5),
ROUND(DBMS_RANDOM.VALUE(50,100)),ROUND(DBMS_RANDOM.VALUE(50,100)),ROUND(DBMS_RANDOM.VALUE(50,100)));



--시퀀스
CREATE SEQUENCE SCORE_SQE
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 100000
    NOCYCLE
    CACHE 2;
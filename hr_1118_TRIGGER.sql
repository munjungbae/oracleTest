--트리거 테스트
DROP TABLE EMP01;

CREATE TABLE EMP01(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(20),
    JOB VARCHAR2(50)
);

DESC EMP01;

CREATE OR REPLACE TRIGGER EMP01_TRIGGER
    AFTER INSERT ON EMP01
    FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO || ', ' || :NEW.ENAME || ' 신입사원');
END;
/

INSERT INTO EMP01 VALUES((SELECT NVL(MAX(EMPNO), 0)+1 FROM EMP01), DBMS_RANDOM.STRING('U', 4), 'IT_DEV');
--(SELECT NVL(MAX(EMPNO), 0)+1 FROM EMP01) << 0부터 1씩 자동으로 증가하는 서브쿼리값, EMPNO가 널이니까 0이 들어가고 +1이 진행되어 1, EMPNO가 1이니까 +1이 진행되어 2 ... 이런식으로 +1씩 증가

CREATE TABLE SAL01(
    SALNO NUMBER(4),
    SAL NUMBER,
    EMPNO NUMBER(4)
    );
ALTER TABLE SAL01 ADD CONSTRAINT SAL01_PK PRIMARY KEY(SALNO);
ALTER TABLE SAL01 ADD CONSTRAINT SAL01_FK FOREIGN KEY(EMPNO) REFERENCES EMP01(EMPNO);

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'SAL01';

CREATE SEQUENCE SAL01_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100000
NOCYCLE
CACHE 2;

CREATE OR REPLACE TRIGGER EMP01_TRIGGER2
AFTER INSERT ON EMP01
FOR EACH ROW
BEGIN
    INSERT INTO SAL01 VALUES (SAL01_SEQ.NEXTVAL, 1000000, :NEW.EMPNO);
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO || '번호 사원이 입력 완료되었습니다');
END;
/

INSERT INTO EMP01 VALUES((SELECT NVL(MAX(EMPNO), 0)+1 FROM EMP01), DBMS_RANDOM.STRING('U', 4), 'IT_DEV');
SELECT * FROM EMP01;
SELECT * FROM SAL01;


--EMP01에서 사원의 정보를 제거 했을 때 SAL01에 해당되는 사원의 정보가 삭제되도록 프로그램

CREATE OR REPLACE TRIGGER EMP01_TRIGGER3
    AFTER DELETE ON EMP01
    FOR EACH ROW
BEGIN 
    --SAL01에 해당되는 번호 삭제
    DELETE FORM SAL01 WHERE EMPNO = :OLD.EMPNO;
     DBMS_OUTPUT.PUT_LINE(:OLD.EMPNO || '번호 사원이 삭제 되었습니다.');
END;
/

DELETE FROM EMP01 WHERE EMPNO = 4;

--상품 테이블 생성
CREATE TABLE PRODUCT(
    PCODE CHAR(6),
    PNAME VARCHAR2(12) NOT NULL,
    PCOMPANY VARCHAR2(12),
    PPRICE NUMBER(8),
    STOCK NUMBER DEFAULT 0
);
ALTER TABLE PRODUCT ADD CONSTRAINT PCODE_PK PRIMARY KEY(PCODE);

INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00001','세탁기', 'LG', 1500000); 
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00002','컴퓨터', 'LG', 1000000); 
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00003','냉장고', '삼성', 4500000);

--입고 테이블 생성
CREATE TABLE RECEIVING(
    RNO NUMBER(6),
    PCODE CHAR(6),
    RDATE DATE DEFAULT SYSDATE,
    RQTY NUMBER(6),
    RPIRCE NUMBER(8),
    RAMOUNT NUMBER(8)
    );
ALTER TABLE RECEIVING ADD CONSTRAINT RNO_PK PRIMARY KEY(RNO);
ALTER TABLE RECEIVING ADD CONSTRAINT RECEIVING_FK FOREIGN KEY(PCODE) REFERENCES PRODUCT(PCODE);

INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPIRCE, RAMOUNT) VALUES(RNO_SEQ2.NEXTVAL, 'A00001', 5, 850000, 950000);
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPIRCE, RAMOUNT) VALUES(RNO_SEQ2.NEXTVAL, 'A00001', 10, 850000, 950000);
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPIRCE, RAMOUNT) VALUES(RNO_SEQ2.NEXTVAL, 'A00002', 10, 950000, 1050000);
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPIRCE, RAMOUNT) VALUES(RNO_SEQ2.NEXTVAL, 'A00003', 15, 1050000, 1150000);
INSERT INTO RECEIVING(RNO, PCODE, RQTY, RPIRCE, RAMOUNT) VALUES(RNO_SEQ2.NEXTVAL, 'A00003', 20, 1050000, 1150000);

--트리거 생성
CREATE OR REPLACE TRIGGER REC_TRIGGER
    AFTER INSERT ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK + :NEW.RQTY WHERE PCODE = :NEW.PCODE;
    DBMS_OUTPUT.PUT_LINE('물건 입력이 완료 되었습니다.');
END;
/
--갱신 트리거 생성
CREATE OR REPLACE TRIGGER REC_TRIGGER2
    AFTER UPDATE ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK - (:OLD.RQTY + :NEW.RQTY) WHERE PCODE = :NEW.PCODE;
    DBMS_OUTPUT.PUT_LINE('수정이 완료 되었습니다');
END;
/

--삭제 트리거 생성.
CREATE OR REPLACE TRIGGER REC_TIRGGER3
    AFTER DELETE ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK - (:OLD.RQTY) WHERE PCODE = :OLD.PCODE;
END;
/

--시퀀스 생성
CREATE SEQUENCE RNO_SEQ2
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100000
NOCYCLE
CACHE 2;

--출력
DROP TABLE PRODUCT;
DROP TABLE RECEIVING;
SELECT * FROM PRODUCT;
SELECT * FROM RECEIVING;
UPDATE RECEIVING SET RQTY =9, RPIRCE = 10000000, RAMOUNT = 1000000 WHERE RNO = 23;
ROLLBACK;
DELETE FROM RECEIVING WHERE RNO = 4;


--FUNCTION 기능테스트
--부서번호를 입력하면 해당부서가 존재하는지 파악 후 부서명을 리턴
CREATE OR REPLACE FUNCTION GET_DEPARTMENT_NAME_FUNC(VDEPARTMENT_ID EMPLOYEES.DEPARTMENT_ID%TYPE)
RETURN VARCHAR2
IS
    VDEPARTMENT_NAME VARCHAR2(100);
    VCOUNT NUMBER := 0;
BEGIN
    --해당부서의 카운트를 체크
    SELECT COUNT(*) INTO VCOUNT FROM EMPLOYEES WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
    
    IF(VCOUNT = 0)THEN
        VDEPARTMENT_NAME := ' 해당부서 없음 ';
    ELSE 
        SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
    END IF;
    RETURN VDEPARTMENT_NAME;
END;
/
--함수를 이용해서 부서번호등 매개변수등록하고 부서명을 구하는 기능 사용
SELECT FIRST_NAME, SALARY, DEPARTMENT_ID, GET_DEPARTMENT_NAME_FUNC(DEPARTMENT_ID) AS "DEPARTMENT_NAME"
FROM EMPLOYEES WHERE FIRST_NAME = 'Lex';

VARIABLE VNAME VARCHAR2;
EXECUTE :VNAME := GET_DEPARTMENT_NAME_FUNC(90);
PRINT VNAME;
